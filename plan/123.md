# Hand-Drawn Texture Preview Story 計画

## 目的
- 手書きキャンバスで描いた内容が WebGL プレビューに即時反映されることを Storybook 上で確認できるデモを作成する。
- 将来の WebGL 統合作業に向けて、テクスチャ更新とレンダラーの同期処理を検証・切り分けしやすくする。

## 実装ステップ案
1. **レンダリングユーティリティ**
   - Storybook 専用の軽量 `useRenderEnginePreview`（仮）を作成し、`createRenderEngine` を初期化・破棄するラッパーを提供。
   - `sceneDefinition` と `textureInput.textures` を受け取り、`requestAnimationFrame` で定期更新する仕組みを用意。

2. **Preview Story コンポーネント**
   - 左側に `TextureDrawCanvas`、右側に `StageCanvas` (WebGL 出力) を並べたレイアウトを構築。
   - Euclidean Half-Plane シーンを最小構成でレンダリングし、base slot のテクスチャとして手書きキャンバスを使用。
   - Story 内で `enableCanvas` と同じハンドルを共有し、描画ごとに `renderEngine.render` を呼び出す。

3. **Storybook Play 関数**
   - キャンバスにストロークを描画 → WebGL 側のピクセルアルファを `expectCanvasFill` で検証。
   - モード切替・クリア操作を実行し、 WebGL 反映が確認できることをテスト。

4. **リソース管理**
   - Storybook の `play` と `cleanup` で `renderEngine.dispose()` を確実に呼び出し、メモリリークを防止。
   - `requestAnimationFrame` を `useEffect` で管理し、アンマウント時にキャンセル。

5. **ドキュメント更新**
   - `docs/history/2025-10-06-euclidean-fill.md` に新ストーリーの利用法と確認手順を追記。

## 検証観点
- 手描きキャンバスでの描画・消去が WebGL 出力に即時反映される。
- Storybook Play で描画→反映→クリアが自動検証できる。
- エンジン初期化・破棄が安全に行われ、タブ切り替えや再レンダリングでもリソースリークしない。

## 実装後の手動確認
- `pnpm storybook` を起動し、`Controls/Hand-Drawn Texture Preview`（仮称）を開いて描画が同期することを確認。
- 手書きキャンバスをクリアして WebGL 側もクリアされることを確認。
